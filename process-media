#!/usr/bin/perl

use strict;
use warnings;

require 5.014;

use Getopt::Long qw/GetOptions/;
use MIME::Types;
use Sys::CPU qw/cpu_count/;
use Term::ReadKey qw/ReadKey ReadMode/;
use threads;
use threads::shared;
use Thread::Queue;
use Time::HiRes qw/sleep/;
use YAML::Tiny;

local $SIG{'INT'}  = \&sig_handler;
local $SIG{'TERM'} = \&sig_handler;

## VARS

my $config_file = 'process-media.yaml';
my $path;
my @threads;
my @objects;
my $opts = {};
our %OPTIONS;

## MAIN

my $conf = YAML::Tiny->read($config_file);

&check_conf();

GetOptions(
    $opts,
    'type=s',
    'format=s',
    'max_threads=i',
    'batch',
    'keep_name',
    'verbose',
    'overwrite',
    'help',
) or die "Error in command line arguments\n";

&check_params();

&set_options();

&get_objects();

if (scalar @objects == 0) {
    print "No files to process, Exiting...\n" if $OPTIONS{'batch'} eq 'false';
    exit 0;
} else {
    if ($OPTIONS{'batch'} eq 'false') {
        print "Found ".scalar @objects." files...\n";
        ReadMode 4;
        my $key = '';
        while($key !~ /^(?:y|n)$/) {
            1 while defined ReadKey -1; # discard any previous input
            print "Proceed ? (y/n): ";
            $key = ReadKey 0;
            print "$key\n";
        }
        ReadMode 0;

        exit 0 if $key ne 'y';
    }
}

my $queue_todo = Thread::Queue->new();
my $queue_done = Thread::Queue->new();

my $run: shared = 1;
$queue_todo->enqueue($_) for @objects;

# start threads
while ($OPTIONS{'max_threads'} >= 1) {
    push @threads, threads->new(\&thread);
    $OPTIONS{'max_threads'}--;
}

# wait first run to finish
sleep 0.05 while $queue_done->pending() < scalar @objects;

$queue_done->end;

# search duplicate name
'Photo'->search_duplicate(@objects);
'Video'->search_duplicate(@objects);

$run = 2;
$queue_todo->enqueue($_) for @objects;
$queue_todo->end;

# waiting for threads to finish
$_->join for @threads;

exit 0;

## FUNCTIONS

sub thread {

    local $SIG{'INT'} = sub { threads->exit(); };

    while (my $obj = $queue_todo->dequeue) {
        if ($run == 1) {
            $obj->get_name();
            $queue_done->enqueue($obj)
        }
        elsif ($run == 2) {
            $obj->exist();
            $obj->create();
            $obj->process();
            $obj->strip();
            $obj->thumbnail() if ref($obj) eq 'Video';
            $obj->integrity();
        }
    }

    return 1;
}

sub sig_handler {
    my $signame = shift;

    # send SIGINT to all running threads and detach it
    foreach my $thr (threads->list) {
        $thr->kill('INT')->detach();
    }

    die "Received a SIG$signame, Exiting...\n";
}

sub set_options {

    $path = $ARGV[0] // './';

    # max_threads
    if (defined $opts->{'max_threads'}) {
        $OPTIONS{'max_threads'} = ($opts->{'max_threads'} == 0) ? Sys::CPU::cpu_count() : $opts->{'max_threads'};
    } else {
        $OPTIONS{'max_threads'} = ($conf->[0]->{'max_threads'} == 0) ? Sys::CPU::cpu_count() : $conf->[0]->{'max_threads'};
    }

    # verbose
    $OPTIONS{'verbose'} = $opts->{'verbose'} ? 'true' : $conf->[0]->{'verbose'};
    
    # overwrite
    $OPTIONS{'overwrite'} = $opts->{'overwrite'} ? 'true' : $conf->[0]->{'overwrite'};

    # keep_name
    $OPTIONS{'keep_name'} = $opts->{'keep_name'} ? 'true' : $conf->[0]->{'keep_name'};

    # batch
    $OPTIONS{'batch'} = $opts->{'batch'} ? 'true' : 'false';

    $OPTIONS{'type'} = $opts->{'type'} // '';

    if (not defined $opts->{'type'}) {
        if (defined $opts->{'format'}) {
            my %t;
            foreach (split(',', $opts->{'format'})) {
                $t{$conf->[1]->{$_}->{'type'}} = 1;
            }
            $OPTIONS{'type'} = join(',', keys %t);
        } else {
            my %t;
            foreach (keys %{ $conf->[1] }) {
                $t{$conf->[1]->{$_}->{'type'}} = 1;
            }
            $OPTIONS{'type'} = join(',', keys %t);
        }
    }

	if (defined $opts->{'format'}) {
        foreach my $fname (split(',', $opts->{'format'})) {
			foreach my $t (split(',', $OPTIONS{'type'})) {
				$OPTIONS{'format'}{$fname} = $conf->[1]->{$fname}
					if $conf->[1]->{$fname}->{'type'} eq $t;
			}
        }
    } else {
		foreach my $fname (keys %{ $conf->[1] }) {
			foreach my $t (split(',', $OPTIONS{'type'})) {
				$OPTIONS{'format'}{$fname} = $conf->[1]->{$fname}
					if $conf->[1]->{$fname}->{'type'} eq $t;
			}
		}
	}

    die "No format found with your type and format combination\n"
        if not exists $OPTIONS{'format'};

	return 1;
}

sub check_conf {

    # options
    foreach (keys %{ $conf->[0] }) {
        die "Unknown options '$_' in config file\n"
            if $_ !~ /^(?:overwrite|max_threads|keep_name|verbose)$/;

        # max_threads
        die "Miss/Bad value for '$_' in config file\n"
            if $_ eq 'max_threads' and $conf->[0]->{$_} !~ /^\d+$/;

        # keep_name
        die "Miss/Bad value for '$_' in config file\n"
            if $_ eq 'keep_name' and $conf->[0]->{$_} !~ /^(?:true|false)$/;

        # verbose
        die "Miss/Bad value for '$_' in config file\n"
            if $_ eq 'verbose' and $conf->[0]->{$_} !~ /^(?:true|false)$/;

        # overwrite
        die "Miss/Bad value for '$_' in config file\n"
            if $_ eq 'overwrite' and $conf->[0]->{$_} !~ /^(?:true|false)$/;
    }

    foreach ('overwrite', 'max_threads', 'keep_name', 'verbose') {
        die "Miss option '$_' in config file\n" if not defined $conf->[0]->{$_};
    }

    # format
    foreach my $fname (keys %{ $conf->[1] }) {
        die "Bad format name '$fname' in config file" if $fname !~ /^[\w-]+$/;

        foreach (keys %{ $conf->[1]->{$fname} }) {
            die "Unknown format options '$_' in config file\n"
                if $_ !~ /^(?:output_dir|type|rotate|compress|strip|resize|codec|reencode|thumbnail)$/;

            # type
            die "Bad option '$_' for format '$fname' in config file\n"
                if $_ eq 'type' and $conf->[1]->{$fname}->{$_} !~ /^(?:photo|video)$/;

            # output_dir
            die "Bad option '$_' for format '$fname' in config file\n"
                if $_ eq 'output_dir' and $conf->[1]->{$fname}->{$_} !~ /^[\w\-\/\.]+$/;

            # rotate
            die "Bad option '$_' for format '$fname' in config file\n"
                if $_ eq 'rotate' and $conf->[1]->{$fname}->{$_} !~ /^(?:true|false)$/;

            # reencode
            die "Bad option '$_' for format '$fname' in config file\n"
                if $_ eq 'reencode' and $conf->[1]->{$fname}->{$_} !~ /^(?:true|false)$/;

            # thumbnail
            die "Bad option '$_' for format '$fname' in config file\n"
                if $_ eq 'thumbnail' and $conf->[1]->{$fname}->{$_} !~ /^(?:true|false)$/;

            # resize
            die "Bad option '$_' for format '$fname' in config file\n"
                if $_ eq 'resize' and $conf->[1]->{$fname}->{$_} !~ /^\d+$/;

            # strip
            if ($_ eq 'strip') {
                if (ref($conf->[1]->{$fname}->{$_}) eq 'ARRAY') {
                    foreach my $tag (@{ $conf->[1]->{$fname}->{$_} }) {
                        die "Bad strip option tag '$tag' for format '$fname' in config file\n" if $tag !~ /^(?:gps|orientation)$/;
                    }
                } else {
                    die "Bad option '$_' for format '$fname' in config file\n"
                        if  $conf->[1]->{$fname}->{$_} !~ /^(?:true|false)$/;
                }
            }

            # compress
            die "Bad option '$_' for format '$fname' in config file\n"
                if $_ eq 'compress' and $conf->[1]->{$fname}->{$_} !~ /^\d+$/ and $conf->[1]->{$fname}->{$_} > 100;
        }

        die "No type defined for format '$fname' in config file\n" if not defined $conf->[1]->{$fname}->{'type'};
    }

    return 1;
}

sub check_params {

    &usage() if $opts->{'help'};

    # type
    if (defined $opts->{'type'}) {
        foreach (split(',', $opts->{'type'})) {
            die "Bad type of files to process: $_, see help (-h) for supported type\n"
                if !/^(?:photo|video)$/;
            my $found = 0;
            foreach my $k (keys %{ $conf->[1] }) {
                $found = 1 if $conf->[1]->{$k}->{'type'} eq $_;
            }
            die "No format found with type '$_'\n" if not $found;
        }
    }

    # format
    if (defined $opts->{'format'}) {
        foreach (split(',', $opts->{'format'})) {
            die "Unknown format '$_'\n" if not defined $conf->[1]->{$_};
        }
    }

    die "Incorrect parameters, see help (-h) for correct syntax\n" if @ARGV > 1;

    return 1;
}

sub get_files {

    my @files;

    if (-f $path) {
        push @files, $path;
    }
    elsif (-d $path) {
        $path .= '/' unless $path =~ /\/$/;
        opendir my $dh, $path or die "Failed to read directory \'$path\': $!\n";
        foreach (sort grep { -f ($path.$_) && !/^\./ } readdir $dh) {
            push @files, $path.$_;
        }
        closedir $dh;
    }

    return @files;
}

sub get_objects {

    my @files = &get_files();

    my $mt = MIME::Types->new();

    foreach (@files) {
        my $obj;
        my $type = $mt->mimeTypeOf($_);
        if (defined $type and $type eq 'image/jpeg') {
            next if $OPTIONS{'type'} !~ /photo/;
            $obj = Photo->new();
        }
        elsif (defined $type and $type eq 'video/mp4') {
            next if $OPTIONS{'type'} !~ /video/;
            $obj = Video->new();
        }
        if (defined $obj) {
            $obj->init($_);
            push @objects, $obj;
        }
    }

    return 1;
}

sub usage {
    print << "EOF";
Usage: $0 [options...] <path>
Options:
-t,--type\t\t{photo,video}\tType of files to process (default: photo,video)
-f,--format\t\t{format1,...}\tFormat to generate (default: all format defined in config file)
-m,--max_threads\t<num_threads>\tMaximum allowed threads (default: number of cpu(s)/core(s))
-k,--keep_name\t\t\t\tDo not rename file
-v,--verbose\t\t\t\tVerbose output
-o,--overwrite\t\t\t\tOverwrite existing files
-b,--batch\t\t\t\tRun in non-interactive mode, allowing to run in a crontab
-h,--help\t\t\t\tThis help text
EOF
    exit 0;
}

## PACKAGES

package Photo {

    use strict;
    use warnings;

    use Carp qw/carp/;
    use File::Basename qw/fileparse/;
    use File::Copy qw/copy/;
    use File::Path qw/make_path/;
    use Image::ExifTool qw/ImageInfo/;
    use Image::Magick;
    use threads::shared;
    use Time::Piece;

    sub new {
        my $class = shift;

        my %obj : shared;

        # with threads, we need to share specifically every sub hash
        $obj{'original'} = &share({});
        $obj{'final'} = &share({});

        bless \%obj, $class;

        return \%obj;
    }

    sub init {
        my ($obj, $f) = @_;

        lock $obj;

        $obj->{'original'}->{'path'} = $f;

        my ($name, $dir, $ext) = fileparse($f, qr/\.[^.]*/);

        $obj->{'original'}->{'name'} = $name;
        $obj->{'original'}->{'dir'} = $dir;
        $obj->{'original'}->{'extension'} = $ext;

        # set final dir
        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'photo';
            $obj->{'final'}->{$_} = &share({});
            if (defined $main::OPTIONS{'format'}{$_}{'output_dir'}) {
                $main::OPTIONS{'format'}{$_}{'output_dir'} =~ s/\/+$//;
                # absolute path
                if ($main::OPTIONS{'format'}{$_}{'output_dir'} =~ /^\//) {
                    $obj->{'final'}->{$_}->{'dir'} = $main::OPTIONS{'format'}{$_}{'output_dir'}.'/';
                } else {
                    $obj->{'final'}->{$_}->{'dir'} = $obj->{'original'}->{'dir'}.$main::OPTIONS{'format'}{$_}{'output_dir'}.'/';
                }
            } else {
                $obj->{'final'}->{$_}->{'dir'} = $obj->{'original'}->{'dir'}.$_.'/';
            }
        }

        $obj->{'final'}->{'extension'} = '.jpg';

        return 1;
    }

    sub get_name {
        my $obj = shift;

        lock $obj;

        if ($main::OPTIONS{'keep_name'} eq 'true') {
            $obj->{'final'}->{'name'} = $obj->{'original'}->{'name'};
        }
        else {
            my $info = ImageInfo($obj->{'original'}->{'path'}, 'CreateDate');

            if (not exists $info->{'CreateDate'}) {
                carp "[$obj->{'original'}->{'path'}] Failed to get capture time";
                return 0;
            }

            my $t = Time::Piece->strptime($info->{'CreateDate'}, "%Y:%m:%d %H:%M:%S");
            $obj->{'final'}->{'name'} = $t->ymd('').'-'.$t->hms('');

            print "[$obj->{'original'}->{'path'}] Renamed to \'$obj->{'final'}->{'name'}\'\n"
            if $main::OPTIONS{'verbose'} eq 'true';
        }

        # set final path
        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'photo';
            $obj->{'final'}->{$_}->{'path'} = $obj->{'final'}->{$_}->{'dir'}
            .$obj->{'final'}->{'name'}
            .$obj->{'final'}->{'extension'};
        }

        return 1;
    }

    sub exist {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'photo';

            print "$obj->{'original'}->{'path'} -> $obj->{'final'}->{$_}->{'path'}\n"
            if $main::OPTIONS{'verbose'} eq 'false' and $main::OPTIONS{'batch'} ne 'true';

            if (-f $obj->{'final'}->{$_}->{'path'}) {
                print "[$obj->{'final'}->{$_}->{'path'}] Already exist...\n"
                if $main::OPTIONS{'overwrite'} eq 'false';

                $obj->{'final'}->{$_}->{'exist'} = 1;
            }
        }

        return 1;
    }

    sub create {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'photo';
            next if defined $obj->{'final'}->{$_}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$_}->{'path'}] Creating...\n" if $main::OPTIONS{'verbose'} eq 'true';

            make_path $obj->{'final'}->{$_}->{'dir'} if not -d $obj->{'final'}->{$_}->{'dir'};
            copy("$obj->{'original'}->{'path'}", "$obj->{'final'}->{$_}->{'path'}");
        }

        return 1;
    }

    sub process {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'photo';
            next if defined $obj->{'final'}->{$_}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$_}->{'path'}] Processing...\n" if $main::OPTIONS{'verbose'} eq 'true';

            my $image = Image::Magick->new();
            if (my $err = $image->Read($obj->{'original'}->{'path'})){
                carp "[$obj->{'final'}->{$_}->{'path'}] Failed to read, $err";
                return 0;
            }
            # physically rotate image according to the exif orientation tag
            if (defined $main::OPTIONS{'format'}{$_}{'rotate'} and $main::OPTIONS{'format'}{$_}{'rotate'} eq 'true' and
                my $err = $image->AutoOrient()) {
                carp "[$obj->{'final'}->{$_}->{'path'}] Failed to auto-orient, $err";
                return 0;
            }
            # resize image to get the larger side to 1920 (only if it is larger than 1920) and preserve aspect ratio
            if (defined $main::OPTIONS{'format'}{$_}{'resize'} and
                my $err = $image->Resize("$main::OPTIONS{'format'}{$_}{'resize'}x$main::OPTIONS{'format'}{$_}{'resize'}>")){
                carp "[$obj->{'final'}->{$_}->{'path'}] Failed to resize, $err";
                return 0;
            }
            my $err;
            if (defined $main::OPTIONS{'format'}{$_}{'compress'}) {
                $err = $image->Write(filename => $obj->{'final'}->{$_}->{'path'}, quality => $main::OPTIONS{'format'}{$_}{'compress'});
            } else {
                $err = $image->Write(filename => $obj->{'final'}->{$_}->{'path'});
            }
            if ($err) {
                carp "[$obj->{'final'}->{$_}->{'path'}] Failed to write, $err";
                return 0;
            }
        }

        return 1;
    }

    sub strip {
        my $obj = shift;

        lock $obj;

        foreach my $fname (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$fname}{'type'} ne 'photo';
            next if not defined $main::OPTIONS{'format'}{$fname}{'strip'} or
            $main::OPTIONS{'format'}{$fname}{'strip'} eq 'false';
            next if defined $obj->{'final'}->{$fname}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$fname}->{'path'}] Stripping...\n" if $main::OPTIONS{'verbose'} eq 'true';

            # remove all tags
            my $exif = Image::ExifTool->new();
            my ($ret, $err) = $exif->SetNewValue('*');
            if (defined $err) {
                carp "[$obj->{'final'}->{$fname}->{'path'}] Failed to remove tags, $err";
                return 0;
            }

            if (ref($main::OPTIONS{'format'}{$fname}{'strip'}) eq 'ARRAY') {

                foreach (@{ $main::OPTIONS{'format'}{$fname}{'strip'} }) {

                    if ($_ eq 'gps') {

                        # keep GPS tags if asked
                        $ret = $exif->SetNewValuesFromFile($obj->{'final'}->{$fname}->{'path'}, 'gps:all');
                        if (defined $ret->{'Error'}) {
                            carp "[$obj->{'final'}->{$fname}->{'path'}] Failed to retrieve tag orientation, $ret->{'Error'}";
                            return 0;
                        }
                    }
                    elsif ($_ eq 'orientation') {
                        # keep Orientation tag
                        $ret = $exif->SetNewValuesFromFile($obj->{'final'}->{$fname}->{'path'}, 'EXIF:Orientation');
                        if (defined $ret->{'Error'}) {
                            carp "[$obj->{'final'}->{$fname}->{'path'}] Failed to retrieve tag orientation, $ret->{'Error'}";
                            return 0;
                        }
                    }
                }
            }

            unless ($exif->WriteInfo($obj->{'final'}->{$fname}->{'path'})) {
                carp "[$obj->{'final'}->{$fname}->{'path'}] Failed to write, ".$exif->GetValue('Error');
                return 0;
            }
        }

        return 1;
    }

    sub integrity {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'photo';
            next if defined $obj->{'final'}->{$_}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$_}->{'path'}] Checking integrity...\n" if $main::OPTIONS{'verbose'} eq 'true';

            &execute($obj->{'final'}->{$_}->{'path'}, 'File is corrupted', "jpeginfo -c $obj->{'final'}->{$_}->{'path'} >/dev/null 2>&1");
        }

        return 1;
    }

    sub search_duplicate {
        my ($class, @files) = @_;

        foreach my $i (0 .. $#files) {
            next if ref($files[$i]) ne 'Photo';
            my %same;
            foreach my $j (0 .. $#files) {
                next if ref($files[$j]) ne 'Photo';
                next if $i == $j;
                if ($files[$i]->{'final'}->{'name'} eq $files[$j]->{'final'}->{'name'}) {
                    $same{$i} = 1;
                    $same{$j} = 1;
                }
            }

            # rename files with same origin name
            my $k = 0;
            foreach my $id (keys %same) {
                $k++;
                $files[$id]->{'final'}->{'name'} .= '-'.sprintf("%03d", $k);
            }
        }

        return 1;
    }

    sub execute {
        my ($file, $msg, $cmd) = @_;

        if (my $wait_status = system $cmd) {
            my $sig_killed   = $wait_status & 127;
            my $did_coredump = $wait_status & 128;
            my $exit_status  = $wait_status >>  8;

            if ($sig_killed) {
                print "Thread number \'".threads->tid()."\' received a SIG signal($sig_killed), Exiting...\n";
                threads->exit();
            }
            if ($exit_status != 0) {
                carp "[$file] $msg, $!";
                return 0;
            }
        }

        return 1;
    }

    return 1;
}

package Video {

    use strict;
    use warnings;

    use Carp qw/carp/;
    use File::Basename qw/fileparse/;
    use File::Copy qw/copy/;
    use File::Path qw/make_path/;
    use Image::ExifTool qw/ImageInfo/;
    use Image::Magick;
    use threads::shared;
    use Time::Piece;

    sub new {
        my $class = shift;

        my %obj : shared;

        # with threads, we need to share specifically every sub hash
        $obj{'original'} = &share({});
        $obj{'final'} = &share({});

        bless \%obj, $class;

        return \%obj;
    }

    sub init {
        my ($obj, $f) = @_;

        lock $obj;

        $obj->{'original'}->{'path'} = $f;

        my ($name, $dir, $ext) = fileparse($f, qr/\.[^.]*/);

        $obj->{'original'}->{'name'} = $name;
        $obj->{'original'}->{'dir'} = $dir;
        $obj->{'original'}->{'extension'} = $ext;

        # set final dir
        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'video';
            $obj->{'final'}->{$_} = &share({});
            if (defined $main::OPTIONS{'format'}{$_}{'output_dir'}) {
                $main::OPTIONS{'format'}{$_}{'output_dir'} =~ s/\/+$//;
                # absolute path
                if ($main::OPTIONS{'format'}{$_}{'output_dir'} =~ /^\//) {
                    $obj->{'final'}->{$_}->{'dir'} = $main::OPTIONS{'format'}{$_}{'output_dir'}.'/';
                } else {
                    $obj->{'final'}->{$_}->{'dir'} = $obj->{'original'}->{'dir'}.$main::OPTIONS{'format'}{$_}{'output_dir'}.'/';
                }
            } else {
                $obj->{'final'}->{$_}->{'dir'} = $obj->{'original'}->{'dir'}.$_.'/';
            }
        }

        $obj->{'final'}->{'extension'} = '.mp4';

        return 1;
    }

    sub get_name {
        my $obj = shift;

        lock $obj;

        if ($main::OPTIONS{'keep_name'} eq 'true') {
            $obj->{'final'}->{'name'} = $obj->{'original'}->{'name'};
        }
        else {
            my $info = ImageInfo($obj->{'original'}->{'path'}, 'CreateDate');

            if (not exists $info->{'CreateDate'}) {
                carp "[$obj->{'original'}->{'path'}] Failed to get capture time";
                return 0;
            }

            my $t = Time::Piece->strptime($info->{'CreateDate'}, "%Y:%m:%d %H:%M:%S");
            $t += $t->localtime->tzoffset;
            $obj->{'final'}->{'name'} = $t->ymd('').'-'.$t->hms('');

            print "[$obj->{'original'}->{'path'}] Renamed to \'$obj->{'final'}->{'name'}\'\n"
            if $main::OPTIONS{'verbose'} eq 'true';
        }

        # set final path
        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'video';
            $obj->{'final'}->{$_}->{'path'} = $obj->{'final'}->{$_}->{'dir'}
            .$obj->{'final'}->{'name'}
            .$obj->{'final'}->{'extension'};
        }

        return 1;
    }

    sub exist {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'video';

            print "$obj->{'original'}->{'path'} -> $obj->{'final'}->{$_}->{'path'}\n"
            if $main::OPTIONS{'verbose'} eq 'false' and $main::OPTIONS{'batch'} ne 'true';

            if (-f $obj->{'final'}->{$_}->{'path'}) {
                print "[$obj->{'final'}->{$_}->{'path'}] Already exist...\n"
                if $main::OPTIONS{'overwrite'} eq 'false';

                $obj->{'final'}->{$_}->{'exist'} = 1;
            }
        }

        return 1;
    }

    sub create {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'video';
            next if defined $obj->{'final'}->{$_}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$_}->{'path'}] Creating...\n" if $main::OPTIONS{'verbose'} eq 'true';

            make_path $obj->{'final'}->{$_}->{'dir'} if not -d $obj->{'final'}->{$_}->{'dir'};
            copy("$obj->{'original'}->{'path'}", "$obj->{'final'}->{$_}->{'path'}");
        }

        return 1;
    }

    sub process {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'video';
            next if not defined $main::OPTIONS{'format'}{$_}{'reencode'} or $main::OPTIONS{'format'}{$_}{'reencode'} eq 'false';
            next if defined $obj->{'final'}->{$_}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$_}->{'path'}] Processing...\n" if $main::OPTIONS{'verbose'} eq 'true';

            my $cmd = "ffmpeg -nostdin -hide_banner -y -loglevel warning -i $obj->{'original'}->{'path'} -codec:a copy -flags +global_header";

            if (defined $main::OPTIONS{'format'}{$_}{'codec'} and $main::OPTIONS{'format'}{$_}{'codec'} eq 'x265') {
                $cmd .= " -codec:v libx265 -x265-params crf=23:log-level=error";
            }

            if (defined $main::OPTIONS{'format'}{$_}{'resize'}) {
                $cmd .= " -vf \"scale='if(gt(iw,ih),$main::OPTIONS{'format'}{$_}{'resize'},trunc(oh*a/2)*2)':'if(gt(iw,ih),trunc(ow/a/2)*2,$main::OPTIONS{'format'}{$_}{'resize'})'\"";
            }

            $cmd .= " $obj->{'final'}->{$_}->{'path'}";

            &execute($obj->{'final'}->{$_}->{'path'}, 'Failed to encode', $cmd);
        }

        return 1;
    }

    sub strip {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'video';
            next if not defined $main::OPTIONS{'format'}{$_}{'strip'} or $main::OPTIONS{'format'}{$_}{'strip'} eq 'false';
            next if defined $obj->{'final'}->{$_}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$_}->{'path'}] Stripping...\n" if $main::OPTIONS{'verbose'} eq 'true';

            # remove all tags
            my $exif = Image::ExifTool->new();
            my ($ret, $err) = $exif->SetNewValue('*');
            if (defined $err) {
                carp "[$obj->{'final'}->{$_}->{'path'}] Failed to remove tags, $err";
                return 0;
            }
            unless ($exif->WriteInfo($obj->{'final'}->{$_}->{'path'})) {
                carp "[$obj->{'final'}->{$_}->{'path'}] Failed to write, ".$exif->GetValue('Error');
                return 0;
            }
        }

        return 1;
    }

    sub thumbnail {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'video';
            next if not defined $main::OPTIONS{'format'}{$_}{'thumbnail'} or $main::OPTIONS{'format'}{$_}{'thumbnail'} eq 'false';
            next if defined $obj->{'final'}->{$_}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$_}->{'path'}] Generating thumbnail...\n" if $main::OPTIONS{'verbose'} eq 'true';

            &execute($obj->{'final'}->{$_}->{'path'}, 'Failed to create thumbnail', "ffmpeg -y -loglevel error -i $obj->{'final'}->{$_}->{'path'} -vframes 1 $obj->{'final'}->{$_}->{'dir'}$obj->{'final'}->{'name'}.jpg");

            my $image = Image::Magick->new();
            if (my $err = $image->Read("$obj->{'final'}->{$_}->{'dir'}$obj->{'final'}->{'name'}.jpg")){
                carp "[$obj->{'final'}->{$_}->{'dir'}$obj->{'final'}->{'name'}.jpg] Failed to read, $err";
                return 0;
            }
            if (my $err = $image->Strip()){
                carp "[$obj->{'final'}->{$_}->{'dir'}$obj->{'final'}->{'name'}.jpg] Failed to strip, $err";
                return 0;
            }
            if (my $err = $image->Write(filename => "$obj->{'final'}->{$_}->{'dir'}$obj->{'final'}->{'name'}.jpg", quality => 90)) {
                carp "[$obj->{'final'}->{$_}->{'dir'}$obj->{'final'}->{'name'}.jpg] Failed to write, $err";
                return 0;
            }
        }

        return 1;
    }

    sub integrity {
        my $obj = shift;

        lock $obj;

        foreach (keys %{ $main::OPTIONS{'format'} }) {
            next if $main::OPTIONS{'format'}{$_}{'type'} ne 'video';
            next if defined $obj->{'final'}->{$_}->{'exist'} and $main::OPTIONS{'overwrite'} eq 'false';

            print "[$obj->{'final'}->{$_}->{'path'}] Checking integrity...\n" if $main::OPTIONS{'verbose'} eq 'true';

            &execute($obj->{'final'}->{$_}->{'path'}, 'File is corrupted', "ffmpeg -loglevel error -i $obj->{'final'}->{$_}->{'path'} -f null -");
        }

        return 1;
    }

    sub search_duplicate {
        my ($class, @files) = @_;

        foreach my $i (0 .. $#files) {
            next if ref($files[$i]) ne 'Video';
            my %same;
            foreach my $j (0 .. $#files) {
                next if ref($files[$j]) ne 'Video';
                next if $i == $j;
                if ($files[$i]->{'final'}->{'name'} eq $files[$j]->{'final'}->{'name'}) {
                    $same{$i} = 1;
                    $same{$j} = 1;
                }
            }

            # rename files with same origin name
            my $k = 0;
            foreach my $id (keys %same) {
                $k++;
                $files[$id]->{'final'}->{'name'} .= '-'.sprintf("%03d", $k);
            }
        }

        return 1;
    }

    sub execute {
        my ($file, $msg, $cmd) = @_;

        if (my $wait_status = system $cmd) {
            my $sig_killed   = $wait_status & 127;
            my $did_coredump = $wait_status & 128;
            my $exit_status  = $wait_status >>  8;

            if ($sig_killed) {
                print "Thread number \'".threads->tid()."\' received a SIG signal($sig_killed), Exiting...\n";
                threads->exit();
            }
            if ($exit_status != 0) {
                carp "[$file] $msg, $!";
                return 0;
            }
        }

        # ffmpeg messes up terminal, this is a workaround
        system('stty sane');

        return 1;
    }

    return 1;
}

## POD

=pod

=head1 NAME

process-media

=head1 DESCRIPTION

This script will process (resize, compress...) photos and videos according to the specified options.

It depends on the following linux binary:

    * ffmpeg
    * jpeginfo

It needs the following ubuntu packages installed:

    * ffmpeg
    * jpeginfo
    * libimage-exiftool-perl
    * libimage-magick-perl
    * libmime-types-perl
    * libsys-cpu-perl
    * libterm-readkey-perl

=head1 AUTHOR

Laurent Lavaud

=cut
